package com.psa.view;

import com.psa.algorithms.FirstComeFirstServed;
import com.psa.algorithms.RoundRobin;
import com.psa.algorithms.ShortestJobFirst;
import com.psa.algorithms.ShortestRemainingTimeFirst;
import com.psa.model.Process;

import com.psa.util.ExcelRead;

import com.psa.util.ExcelWrite;

import com.psa.util.ProcessorCalculations;

import java.awt.Dimension;

import java.io.File;
import java.io.FileNotFoundException;

import java.io.IOException;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import java.util.Queue;

import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author omaar
 */
public class MainFrame extends javax.swing.JFrame {

    private List<Process> inputProcesses = new ArrayList<>();
    private Queue outputQueue = new LinkedList<>();

    private String currentAlgorithmTitle = "";

    /** Creates new form MainFrame */
    public MainFrame() {
        initComponents();
        
        //set frame title
        setTitle("Task Scheduling Application");
        
        //clear input and output tables
        clearOutputTable();
        clearInputTable();

    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    private void initComponents() {//GEN-BEGIN:initComponents

        frameTitleLabel = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        exportButton = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        outputTable = new javax.swing.JTable();
        algorithmComboBox = new javax.swing.JComboBox<>();
        runAlgorithmButton = new javax.swing.JButton();
        jPanel3 = new javax.swing.JPanel();
        quantumTestField = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        chooseExcelButton = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        inputTable = new javax.swing.JTable();
        jPanel2 = new javax.swing.JPanel();
        jPanel4 = new javax.swing.JPanel();
        algorithmTitleLabel = new javax.swing.JLabel();
        waitingTimePannel = new javax.swing.JPanel();
        jLabel4 = new javax.swing.JLabel();
        averageWaitingTimeLabel = new javax.swing.JLabel();
        responesTimePanel = new javax.swing.JPanel();
        jLabel5 = new javax.swing.JLabel();
        averageResponseTimeLabel = new javax.swing.JLabel();
        turnAroundTimePanel = new javax.swing.JPanel();
        jLabel6 = new javax.swing.JLabel();
        averageTurnAroundTimeLabel = new javax.swing.JLabel();
        cpuUtilizationPanel = new javax.swing.JPanel();
        jLabel7 = new javax.swing.JLabel();
        cpuUtilizationLabel = new javax.swing.JLabel();
        throughputPanel = new javax.swing.JPanel();
        jLabel8 = new javax.swing.JLabel();
        throughputLabel = new javax.swing.JLabel();
        jPanel5 = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        frameTitleLabel.setFont(new java.awt.Font("Acme", 0, 24)); // NOI18N
        frameTitleLabel.setText("Task Scheduling Application (GROUP 3)");
        getContentPane().add(frameTitleLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(410, 10, -1, 32));

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder("Output"));
        jPanel1.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        jLabel1.setText("Choose Algorithm");
        jPanel1.add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(40, 30, -1, -1));

        exportButton.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        exportButton.setText("Export");
        exportButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exportButtonActionPerformed(evt);
            }
        });
        jPanel1.add(exportButton, new org.netbeans.lib.awtextra.AbsoluteConstraints(280, 50, 100, 25));

        outputTable.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        outputTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null}
            },
            new String [] {
                "TASK", "START", "END", "DURATION", "STATUS"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false, true
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        outputTable.setMaximumSize(new java.awt.Dimension(240, 64));
        outputTable.setPreferredSize(new java.awt.Dimension(300, 5000));
        outputTable.setRowHeight(25);
        jScrollPane1.setViewportView(outputTable);

        jPanel1.add(jScrollPane1, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 90, 390, 440));

        algorithmComboBox.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        algorithmComboBox.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "All", "FCFS", "SJF", "SRTF", "RR", "EDF" }));
        algorithmComboBox.setPreferredSize(new java.awt.Dimension(100, 25));
        algorithmComboBox.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                algorithmComboBoxItemStateChanged(evt);
            }
        });
        jPanel1.add(algorithmComboBox, new org.netbeans.lib.awtextra.AbsoluteConstraints(40, 50, 90, -1));

        runAlgorithmButton.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        runAlgorithmButton.setText("Run Algorithm");
        runAlgorithmButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                runAlgorithmButtonActionPerformed(evt);
            }
        });
        jPanel1.add(runAlgorithmButton, new org.netbeans.lib.awtextra.AbsoluteConstraints(160, 50, 100, 25));

        getContentPane().add(jPanel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(390, 50, 410, 540));

        jPanel3.setBorder(javax.swing.BorderFactory.createTitledBorder("Input"));
        jPanel3.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        quantumTestField.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        jPanel3.add(quantumTestField, new org.netbeans.lib.awtextra.AbsoluteConstraints(40, 50, 100, 25));

        jLabel3.setText("Quantum");
        jPanel3.add(jLabel3, new org.netbeans.lib.awtextra.AbsoluteConstraints(40, 30, -1, -1));

        chooseExcelButton.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        chooseExcelButton.setText("Choose Excel File");
        chooseExcelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                chooseExcelButtonActionPerformed(evt);
            }
        });
        jPanel3.add(chooseExcelButton, new org.netbeans.lib.awtextra.AbsoluteConstraints(190, 50, 150, 25));

        inputTable.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        inputTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "TASK", "ARRIVAL", "DURATION", "DEADLINE"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        inputTable.setMaximumSize(new java.awt.Dimension(240, 64));
        inputTable.setPreferredSize(new java.awt.Dimension(300, 500));
        inputTable.setRowHeight(25);
        jScrollPane3.setViewportView(inputTable);

        jPanel3.add(jScrollPane3, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 90, 370, 440));

        getContentPane().add(jPanel3, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 50, 390, 540));

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder("Calculations"));
        jPanel2.setLayout(new java.awt.GridLayout(7, 0));

        algorithmTitleLabel.setFont(new java.awt.Font("SansSerif", 0, 22)); // NOI18N
        algorithmTitleLabel.setText("Algorithm Title");

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup()
                .addContainerGap(122, Short.MAX_VALUE)
                .addComponent(algorithmTitleLabel)
                .addGap(120, 120, 120))
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addGap(20, 20, 20)
                .addComponent(algorithmTitleLabel)
                .addContainerGap(25, Short.MAX_VALUE))
        );

        jPanel2.add(jPanel4);

        jLabel4.setFont(new java.awt.Font("SansSerif", 0, 22)); // NOI18N
        jLabel4.setText("Average Waiting Time :");

        averageWaitingTimeLabel.setFont(new java.awt.Font("SansSerif", 0, 22)); // NOI18N
        averageWaitingTimeLabel.setText("0");

        javax.swing.GroupLayout waitingTimePannelLayout = new javax.swing.GroupLayout(waitingTimePannel);
        waitingTimePannel.setLayout(waitingTimePannelLayout);
        waitingTimePannelLayout.setHorizontalGroup(
            waitingTimePannelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(waitingTimePannelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 98, Short.MAX_VALUE)
                .addComponent(averageWaitingTimeLabel)
                .addGap(32, 32, 32))
        );
        waitingTimePannelLayout.setVerticalGroup(
            waitingTimePannelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(waitingTimePannelLayout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addGroup(waitingTimePannelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(averageWaitingTimeLabel)
                    .addComponent(jLabel4))
                .addContainerGap(23, Short.MAX_VALUE))
        );

        jPanel2.add(waitingTimePannel);

        jLabel5.setFont(new java.awt.Font("SansSerif", 0, 22)); // NOI18N
        jLabel5.setText("Average Response Time :");

        averageResponseTimeLabel.setFont(new java.awt.Font("SansSerif", 0, 22)); // NOI18N
        averageResponseTimeLabel.setText("0");

        javax.swing.GroupLayout responesTimePanelLayout = new javax.swing.GroupLayout(responesTimePanel);
        responesTimePanel.setLayout(responesTimePanelLayout);
        responesTimePanelLayout.setHorizontalGroup(
            responesTimePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(responesTimePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel5)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 73, Short.MAX_VALUE)
                .addComponent(averageResponseTimeLabel)
                .addGap(31, 31, 31))
        );
        responesTimePanelLayout.setVerticalGroup(
            responesTimePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(responesTimePanelLayout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addGroup(responesTimePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(averageResponseTimeLabel)
                    .addComponent(jLabel5))
                .addContainerGap(23, Short.MAX_VALUE))
        );

        jPanel2.add(responesTimePanel);

        jLabel6.setFont(new java.awt.Font("SansSerif", 0, 22)); // NOI18N
        jLabel6.setText("Average Turn Around Time :");

        averageTurnAroundTimeLabel.setFont(new java.awt.Font("SansSerif", 0, 22)); // NOI18N
        averageTurnAroundTimeLabel.setText("0");

        javax.swing.GroupLayout turnAroundTimePanelLayout = new javax.swing.GroupLayout(turnAroundTimePanel);
        turnAroundTimePanel.setLayout(turnAroundTimePanelLayout);
        turnAroundTimePanelLayout.setHorizontalGroup(
            turnAroundTimePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(turnAroundTimePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel6)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 53, Short.MAX_VALUE)
                .addComponent(averageTurnAroundTimeLabel)
                .addGap(31, 31, 31))
        );
        turnAroundTimePanelLayout.setVerticalGroup(
            turnAroundTimePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(turnAroundTimePanelLayout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addGroup(turnAroundTimePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(averageTurnAroundTimeLabel)
                    .addComponent(jLabel6))
                .addContainerGap(23, Short.MAX_VALUE))
        );

        jPanel2.add(turnAroundTimePanel);

        jLabel7.setFont(new java.awt.Font("SansSerif", 0, 22)); // NOI18N
        jLabel7.setText("CPU Utilization :");

        cpuUtilizationLabel.setFont(new java.awt.Font("SansSerif", 0, 22)); // NOI18N
        cpuUtilizationLabel.setText("0");

        javax.swing.GroupLayout cpuUtilizationPanelLayout = new javax.swing.GroupLayout(cpuUtilizationPanel);
        cpuUtilizationPanel.setLayout(cpuUtilizationPanelLayout);
        cpuUtilizationPanelLayout.setHorizontalGroup(
            cpuUtilizationPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(cpuUtilizationPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel7)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 167, Short.MAX_VALUE)
                .addComponent(cpuUtilizationLabel)
                .addGap(30, 30, 30))
        );
        cpuUtilizationPanelLayout.setVerticalGroup(
            cpuUtilizationPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(cpuUtilizationPanelLayout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addGroup(cpuUtilizationPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(cpuUtilizationLabel)
                    .addComponent(jLabel7))
                .addContainerGap(23, Short.MAX_VALUE))
        );

        jPanel2.add(cpuUtilizationPanel);

        jLabel8.setFont(new java.awt.Font("SansSerif", 0, 22)); // NOI18N
        jLabel8.setText("Throughput");

        throughputLabel.setFont(new java.awt.Font("SansSerif", 0, 22)); // NOI18N
        throughputLabel.setText("0");

        javax.swing.GroupLayout throughputPanelLayout = new javax.swing.GroupLayout(throughputPanel);
        throughputPanel.setLayout(throughputPanelLayout);
        throughputPanelLayout.setHorizontalGroup(
            throughputPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(throughputPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel8)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 219, Short.MAX_VALUE)
                .addComponent(throughputLabel)
                .addGap(29, 29, 29))
        );
        throughputPanelLayout.setVerticalGroup(
            throughputPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(throughputPanelLayout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addGroup(throughputPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(throughputLabel)
                    .addComponent(jLabel8))
                .addContainerGap(23, Short.MAX_VALUE))
        );

        jPanel2.add(throughputPanel);
        jPanel2.add(jPanel5);

        getContentPane().add(jPanel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(800, 50, 390, 540));

        pack();
    }//GEN-END:initComponents

    private void runAlgorithmButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runAlgorithmButtonActionPerformed
        onRunAlgorithmButtonClick();
    }//GEN-LAST:event_runAlgorithmButtonActionPerformed

    private void exportButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exportButtonActionPerformed
        exportExcel();
    }//GEN-LAST:event_exportButtonActionPerformed

    private void algorithmComboBoxItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_algorithmComboBoxItemStateChanged
        clearOutputTable();
    }//GEN-LAST:event_algorithmComboBoxItemStateChanged

    private void chooseExcelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_chooseExcelButtonActionPerformed
        onChooseExcelButtonClick();
    }//GEN-LAST:event_chooseExcelButtonActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox<String> algorithmComboBox;
    private javax.swing.JLabel algorithmTitleLabel;
    private javax.swing.JLabel averageResponseTimeLabel;
    private javax.swing.JLabel averageTurnAroundTimeLabel;
    private javax.swing.JLabel averageWaitingTimeLabel;
    private javax.swing.JButton chooseExcelButton;
    private javax.swing.JLabel cpuUtilizationLabel;
    private javax.swing.JPanel cpuUtilizationPanel;
    private javax.swing.JButton exportButton;
    private javax.swing.JLabel frameTitleLabel;
    private javax.swing.JTable inputTable;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTable outputTable;
    private javax.swing.JTextField quantumTestField;
    private javax.swing.JPanel responesTimePanel;
    private javax.swing.JButton runAlgorithmButton;
    private javax.swing.JLabel throughputLabel;
    private javax.swing.JPanel throughputPanel;
    private javax.swing.JPanel turnAroundTimePanel;
    private javax.swing.JPanel waitingTimePannel;
    // End of variables declaration//GEN-END:variables

    //-------------------------------Input methods--------------------------------------------

    private void onChooseExcelButtonClick() {

        //Create JFileChooser Object
        JFileChooser fileChooser = new JFileChooser();
        FileFilter filter = new FileNameExtensionFilter("xls files", "xls"); //filter to show only that
        fileChooser.addChoosableFileFilter(filter); //add filter to the fileChooser
        fileChooser.setAcceptAllFileFilterUsed(false); //to show or not all other files
        //set mode to view files and directories
        fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
        //set USER DESKTOP as the opening directory
        fileChooser.setCurrentDirectory(new File(System.getProperty("user.home") + "\\Desktop"));
        int returnValue = fileChooser.showOpenDialog(null); //get returned value
        //if returned value equals APPROVE_OPTION
        if (returnValue == JFileChooser.APPROVE_OPTION) {
            File selectedFile = fileChooser.getSelectedFile(); //get selected file
            String filePath = selectedFile.getAbsolutePath(); //get selected path
            try {

                //clear table and last selections
                clearInputTable();
                inputProcesses.clear();

                //create excel read file object
                ExcelRead excelRead = new ExcelRead();
                //get processes from the selected excel file
                inputProcesses = excelRead.readProcesses(filePath);
                try {
                    //set processes to the input tablee
                    setInputTableModel(inputProcesses);
                } catch (Exception e) {
                    JOptionPane.showMessageDialog(null, "Unkown Error Occured, Please try again later");
                }

            } catch (FileNotFoundException e) {
                JOptionPane.showMessageDialog(null,
                                              "Unkown Error Occured, Please try again later or make sure excel file is in right format");
            }

        }


    }
    
    //-------------------------------Algorithms methods--------------------------------------------

    private void onRunAlgorithmButtonClick() {

        //get algorithm combo box selected index
        int algorithmComboBoxIndex = algorithmComboBox.getSelectedIndex();

        //if user didnot choose any item
        if (algorithmComboBoxIndex == -1) {
            JOptionPane.showMessageDialog(null, "Please Select Algorithm first");

        } else if (algorithmComboBoxIndex == 0) {
            //if user choosed all algorithms



        }else if (algorithmComboBoxIndex == 1) {
            
            //if user choosed first come first served algorithm

            //run algorithm
            firstComeFirstServed(inputProcesses);


        }else if (algorithmComboBoxIndex == 2) {
            
            //if user choosed shortest job first algorithm

            //run algorithm
            shortestJobFirst(inputProcesses);


        }else if (algorithmComboBoxIndex == 3) {
            
            //if user choosed shortest job first algorithm

            //run algorithm
            shortestRemainingTimeFirst(inputProcesses);


        } else if (algorithmComboBoxIndex == 4) {
            
            //if user choosed round robin algorithm
            int quantum;
            
            try {
                quantum = Integer.parseInt(quantumTestField.getText());
                if (quantum < 1) {
                    JOptionPane.showMessageDialog(null, "Please enter a positive integer for the quantum");
                    return;
                }
            } catch (NumberFormatException e) {
                JOptionPane.showMessageDialog(null, "Please enter a numerical value for the quantum");
                return;
            }

            //run algorithm
            roundRobin(inputProcesses, quantum);

        }
        
        setCalculations() ;

    }

    private void roundRobin(List<Process> inputProcesses, int quantum) {

        //clear output queue and table
        clearOutputTable();
        outputQueue.clear();

        //create round robin algorithm object
        RoundRobin RR = new RoundRobin();
        //run algorithm and store result in a queue
        Queue<Process> outputQueuee = RR.runAlgorithm(inputProcesses, quantum);
        outputQueue = outputQueuee ;
        //set current algorithm title variable to round robin
        currentAlgorithmTitle = "Round Robin";

    }

    private void firstComeFirstServed(List<Process> inputProcesses) {

        //clear output queue and table
        clearOutputTable();
        outputQueue.clear();

        //create round robin algorithm object
        FirstComeFirstServed FCFS = new FirstComeFirstServed();
        //run algorithm and store result in a queue
        outputQueue = FCFS.runAlgorithm(inputProcesses);
        //set current algorithm title variable to round robin
        currentAlgorithmTitle = "First Come First Served";

        //convert queue to list and pass it to the table
        List<Process> outputProcess = new ArrayList<>(outputQueue);
        setOutputTableModel(outputProcess);

    }

    private void shortestJobFirst(List<Process> inputProcesses) {

        //clear output queue and table
        clearOutputTable();
        outputQueue.clear();

        //create round robin algorithm object
        ShortestJobFirst SJF = new ShortestJobFirst();
        //run algorithm and store result in a queue
        outputQueue = SJF.runAlgorithm(inputProcesses);
        //set current algorithm title variable to round robin
        currentAlgorithmTitle = "Shortest Job First";

        //convert queue to list and pass it to the table
        List<Process> outputProcess = new ArrayList<>(outputQueue);
        setOutputTableModel(outputProcess);

    }

    private void shortestRemainingTimeFirst(List<Process> inputProcesses) {

        //clear output queue and table
        clearOutputTable();
        outputQueue.clear();

        //create round robin algorithm object
        ShortestRemainingTimeFirst SRTF = new ShortestRemainingTimeFirst();
        //run algorithm and store result in a queue
        outputQueue = SRTF.runAlgorithm(inputProcesses);
        //set current algorithm title variable to round robin
        currentAlgorithmTitle = "Shortest Remaining Time First";

        //convert queue to list and pass it to the table
        List<Process> outputProcess = new ArrayList<>(outputQueue);
        setOutputTableModel(outputProcess);

    }
    
    private void setCalculations(){

        //convert queue to list and pass it to the table
        List<Process> outputProcess = new ArrayList<>(outputQueue);
        setOutputTableModel(outputProcess);
        
        algorithmTitleLabel.setText(currentAlgorithmTitle);
        
        //create a ProcessorCalculations class for the calculations
        ProcessorCalculations PC = new ProcessorCalculations() ;
        
        float averageWaitingTime = PC.averageWaitingTime(outputProcess) ;
        averageWaitingTimeLabel.setText(String.valueOf(averageWaitingTime)) ;
        
        float averageResponseTime = PC.averageResponseTime(outputProcess) ;
        averageResponseTimeLabel.setText(String.valueOf(averageResponseTime)) ;
        
        float averageTurnAroundTime = PC.averageTurnAroundTime(outputProcess) ;
        averageTurnAroundTimeLabel.setText(String.valueOf(averageTurnAroundTime)) ;
        
        float cpuUtilization = PC.cpuUtilization(outputProcess) ;
        cpuUtilizationLabel.setText(String.valueOf(cpuUtilization) + "%") ;
        
        float throughput = PC.Throughput(outputProcess) ;
        throughputLabel.setText(String.valueOf(throughput)) ;
        

    }
    
    //-------------------------------Export methods--------------------------------------------

    private void exportExcel() {

        //Create JFileChooser Object
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setApproveButtonText("Save");
        //set mode to view files and directories
        fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
        //set USER DESKTOP as the opening directory
        fileChooser.setCurrentDirectory(new File(System.getProperty("user.home") + "\\Desktop"));
        int returnValue = fileChooser.showOpenDialog(null); //get returned value
        //if returned value equals APPROVE_OPTION
        if (returnValue == JFileChooser.APPROVE_OPTION) {
            File selectedFile = fileChooser.getSelectedFile(); //get selected file
            String filePath = selectedFile.getAbsolutePath(); //get selected path

            //check if file already exist
            File xmlFile = new File(filePath + ".xls");
            if (xmlFile.exists()) {
                int response = JOptionPane.showConfirmDialog(null, //
                                                             "File already exists, Do you want to replace it ?", //
                                                             "Confirm", JOptionPane.YES_NO_OPTION, //
                                                             JOptionPane.QUESTION_MESSAGE);
                if (response != JOptionPane.YES_OPTION) {
                    return;
                }
            }

            try {
                //write output excel file
                ExcelWrite excelWrite = new ExcelWrite();
                excelWrite.writeProcesses(outputQueue, currentAlgorithmTitle, filePath);
            } catch (IOException e) {
                JOptionPane.showMessageDialog(null, "Unkown Error Occured, Please try again later");
            }
        }
    }
    
    //-------------------------------Tabels methods--------------------------------------------

    private void setInputTableModel(List<Process> processes) {

        Object[][] processesArr = new Object[processes.size()][4];

        for (int i = 0; i < processes.size(); i++) {
            processesArr[i][0] = processes.get(i).getProcessName();
            processesArr[i][1] = processes.get(i).getArriveTime();
            processesArr[i][2] = processes.get(i).getBurstTime();
            processesArr[i][3] = processes.get(i).getDeadline();
        }
        inputTable.setModel(new DefaultTableModel(processesArr,
                                                  new String[] { "TASK", "ARRIVAL", "DURATION", "DEADLINE" }) {
                @Override
                public boolean isCellEditable(int row, int column) {
                    return false;
                }
            });

        //set table dimension
        Dimension dim = new Dimension(300, outputTable.getRowCount() * 25) ;
        inputTable.setPreferredSize(dim);
        inputTable.setFillsViewportHeight(true);
    }

    private void clearInputTable() {

        Object[][] processesArr = new Object[0][4];

        inputTable.setModel(new DefaultTableModel(processesArr,
                                                  new String[] { "TASK", "ARRIVAL", "DURATION", "DEADLINE" }) {
                @Override
                public boolean isCellEditable(int row, int column) {
                    return false;
                }
            });

        //set table dimension
        Dimension dim = new Dimension(300, 0) ;
        inputTable.setPreferredSize(dim);
        inputTable.setFillsViewportHeight(true);
    }

    private void setOutputTableModel(List<Process> processes) {

        Object[][] processesArr = new Object[processes.size()][5];

        for (int i = 0; i < processes.size(); i++) {
            processesArr[i][0] = processes.get(i).getProcessName();
            processesArr[i][1] = processes.get(i).getStartTime();
            processesArr[i][2] = processes.get(i).getEndTime();
            processesArr[i][3] = processes.get(i).getBurstTime();

            if (processes.get(i).getEndTime() > processes.get(i).getDeadline())
                processesArr[i][4] = "F";
            else
                processesArr[i][4] = "S";

        }
        outputTable.setModel(new DefaultTableModel(processesArr,
                                                   new String[] { "TASK", "START", "END", "DURATION", "STATUS" }) {
                @Override
                public boolean isCellEditable(int row, int column) {
                    return false;
                }
            });

        //set table dimension
        Dimension dim = new Dimension(300, outputTable.getRowCount() * 25) ;
        outputTable.setPreferredSize(dim);
        outputTable.setFillsViewportHeight(true);
    }

    private void clearOutputTable() {

        Object[][] processesArr = new Object[0][5];

        outputTable.setModel(new DefaultTableModel(processesArr,
                                                   new String[] { "TASK", "START", "END", "DURATION", "STATUS" }) {
                @Override
                public boolean isCellEditable(int row, int column) {
                    return false;
                }
            });
    
        //set table dimension
        Dimension dim = new Dimension(300, 0) ;
        outputTable.setPreferredSize(dim);
        outputTable.setFillsViewportHeight(true);
    }

}
